<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Danny Lane]]></title><description><![CDATA[Notes To _Self]]></description><link>https://dannylane.github.io</link><image><url>https://github.com/dannylane/dannylane.github.io/raw/master/images/zoom.png</url><title>Danny Lane</title><link>https://dannylane.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Fri, 10 Mar 2017 21:14:54 GMT</lastBuildDate><atom:link href="https://dannylane.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Troubleshooting TFS DB Growth]]></title><description><![CDATA[<div class="paragraph">
<p><strong>Spoiler:</strong> This was caused by ReleaseManager 2013 retaining builds. Read on for the work around that was put in place.</p>
</div>
<div class="paragraph">
<p>As part of a project I was working on recently; I put in a lot of work around TFS Builds, Unit/Integration Tests &amp; continous delivery using ReleaseManager.</p>
</div>
<div class="paragraph">
<p>It was a fairly standard pipeline:<br>
→ Checkin → Unit &amp; Integration Tests Run → Build → Release To Test</p>
</div>
<div class="paragraph">
<p>Up until this project the TFS Build hadn&#8217;t been used, TFS was just used for source control and some workitem tracking, it was hosted on a VM and didn&#8217;t take up much apce <strong><strong></strong></strong>**TODO The DB for TFS was a SQL express on the TFS VM (it has since been moved off to a physical server with DR)</p>
</div>
<div class="paragraph">
<p>After a few months of the project I started getting reports that the TFS VM size was growing constantly. IT had to increase the disk size on the VMs a couple of times.</p>
</div>
<div class="paragraph">
<p>It turns out that the VM had grown from ***TODO</p>
</div>
<div class="paragraph">
<p>After doing a little research online I found the following query that gives some insight into which tables are taking up the most space in the db.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">USE Tfs_DefaultCollection

SELECT
    t.NAME AS TableName,
    s.Name AS SchemaName,
    p.rows AS RowCounts,
    SUM(a.total_pages) * 8 AS TotalSpaceKB,
    SUM(a.used_pages) * 8 AS UsedSpaceKB,
    (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB
FROM
    sys.tables t
INNER JOIN
    sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN
    sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN
    sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN
    sys.schemas s ON t.schema_id = s.schema_id
GROUP BY
    t.Name, s.Name, p.Rows
ORDER BY
    TotalSpaceKB desc</code></pre>
</div>
</div>
<div class="paragraph">
<p>**TODO table with high storage &amp; explanation</p>
</div>
<div class="paragraph">
<p>Normally TFS retains builds as defined by a build retention policy, ours tells it to only keep the last 10 builds.<br>
However, there is a known issue with the Microsoft Release Management 2013 that causes every build that is involved in a release to be retained indefinitely, this doesn&#8217;t really fit with the continous delivery model and has been changed in newer versions.<br>
Every check in we do triggers a build which triggers a release so all our builds are retained.</p>
</div>
<div class="paragraph">
<p>This has issues for the storage capacity on the drops folder where builds are dropped and also storage capacity in the database.</p>
</div>
<div class="paragraph">
<p>The issue was exacerbated for this project because of the logging setup in the integration tests. Each test class library gets a DB deployed and dropped and seed scripts run, all the logging from these activities is echoed to the console. The application logging is also set to console output.<br>
All this log info for each test run is stored in the TFS database which grew unmanageably.<br>
The logging was turned off on the automated builds so this should help keep the size down for newer builds</p>
</div>
<div class="ulist">
<ul>
<li>
<p>todo logmanager stuff for builds</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To manage the retained builds I wrote a powershell script that does the following steps for every build older than 2 weeks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Update the Retain Indefinitely flag to false</p>
</li>
<li>
<p>Delete the build</p>
</li>
<li>
<p>Destroy the build</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Delete the build</strong><br>
This is what is available through the UI, it is only a logical delete and while it does delete artifacts from the network drop folders, it does not delete rows from the db</p>
</div>
<div class="paragraph">
<p><strong>Destroy the build</strong><br>
This is the delete from the db. This is not available though the UI and is only available through the API</p>
</div>
<div class="paragraph">
<p>I setup a build in TFS that runs at 3am every day and runs this scripts as part of the build.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell"> ----
 param ($serverName = 'http://&lt;snip&gt;:8080/tfs/DefaultCollection')</code></pre>
</div>
</div>
<div class="paragraph">
<p>[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Client")<br>
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Build.Client")<br>
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.VersionControl.Client")<br>
$tfs = [Microsoft.TeamFoundation.Client.TeamFoundationServerFactory]::GetServer($serverName)</p>
</div>
<div class="paragraph">
<p>$buildServer =  $tfs.GetService([Microsoft.TeamFoundation.Build.Client.IBuildServer])<br>
$vcs =  $tfs.GetService([Microsoft.TeamFoundation.VersionControl.Client.VersionControlServer])</p>
</div>
<div class="paragraph">
<p>$projects = $vcs.GetAllTeamProjects($true) # We will run this for all team projects</p>
</div>
<div class="paragraph">
<p>foreach ($project in $projects){<br>
    Write-Host $project.Name</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$buildDefs = $buildServer.QueryBuildDefinitions($project.Name) # Get all the build definitions for a given project</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  foreach ($buildDef in $buildDefs){
      Write-Host "-" + $buildDef.Name
$endDate = (Get-Date).AddDays(-14) # Delete all builds older than 14 days. This is a bit aggressive and can be pushed to a month once the logs are smaller on automated builds.
      while($endDate.Year -ge 2014){ # Keep going back until we hit dec 2014
          $year = $endDate.Year
          $month = $endDate.Month
          write-host $year $month
          $buildDetailSpec = $buildServer.CreateBuildDetailSpec($project.Name, $buildDef.Name) # Create a search object for the project/build def
          $startDate = $endDate.addMonths(-1)
          $buildDetailSpec.MaxFinishTime = $endDate # Search criteria
          $buildDetailSpec.MinFinishTime = $startDate # Search criteria
          $buildDetailSpec.InformationTypes = $null # only build info, not workitems, labels, etc</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## This is important for the query, builds that are deletd by retention or the ui are only logically deleted, not destroyed in the db
         $buildDetailSpec.QueryDeletedOption = [Microsoft.TeamFoundation.Build.Client.QueryDeletedOption]::IncludeDeleted</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>$builds = $buildServer.QueryBuilds($buildDetailSpec) # Search all the things
if($builds.Builds.Length -ge 1){
    Write-Host "before update" $builds.Builds
    foreach($build in $builds.Builds){ # Need to turn off the Keep Forever (Retain) flag set by Release Manager.
        if ($build.KeepForever -eq $true){
            Write-Host "Updating build " $build.Uri
            $buildToEdit = $buildServer.GetBuild($build.Uri) # Gets an updatable ref to the build
            $buildToEdit.KeepForever = $false; # Edit the build flag
            $buildServer.SaveBuilds(@($buildToEdit)) # save the build back to the tfs
        }
    }
    $builds = $buildServer.QueryBuilds($buildDetailSpec) # refresh the query given that some of the builds have been updated
    Write-Host "after refresh" $builds.Builds
    $buildServer.DeleteBuilds($builds.Builds, [Microsoft.TeamFoundation.Build.Client.DeleteOptions]::All) # Delete the build, test results, symbols, drop, etc.
    $buildServer.DestroyBuilds($builds.Builds) # Destroy the db records
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>            $endDate = $endDate.addMonths(-1) # rolling back the years.
        }
    }
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>|===
|TableName|SchemaName|RowCounts|TotalSpaceKB|UsedSpaceKB|UnusedSpaceKB
|tbl_Content|dbo|69733|1889136|1869000|20136

|tbl_TestResult|dbo|174868|323192|321504|1688

|tbl_LocalVersion|dbo|413449|122072|120048|2024

|tbl_BuildCodeChange|dbo|148950|78016|77824|192

|tbl_Version|dbo|101484|68872|68544|328

|tbl_BuildInformation2|dbo|88673|64232|63512|720

|tbl_Command|dbo|92974|39192|38928|264
|===

++ You can see the output from the script in the Diagnostics tab from the build:
++ This is where the script is configured:
++ This is the build trigger:





image::buildpurge/dummyproject.png[]</pre>
</div>
</div>]]></description><link>https://dannylane.github.io/2017/03/14/Troubleshooting-TFS-DB-Growth.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/14/Troubleshooting-TFS-DB-Growth.html</guid><category><![CDATA[TFS]]></category><category><![CDATA[ ReleaseManager]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 14 Mar 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Extending EntityFramework Generated Model Classes With T4 Templates]]></title><description><![CDATA[<div class="paragraph">
<p>I was working on a project recently where we used a common pattern for versioning DB records. Extending the EF generated model classes made it easier for the team to apply the pattern consistently.<br>
I updated the generated code to render a generic interface if specific properties exist on the model. 2 helper methods (<code>Clone</code> &amp; <code>Update</code>) were added to the models and were regenerated whenever the model was refreshed.</p>
</div>
<div id="img-project" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/project.png" alt="project.png">
</div>
<div class="title">Figure 1. EnttityVersion.ttinclude</div>
</div>
<div class="paragraph">
<p>I added new templating content as methods exposed in a <code>.ttinclude</code> file.</p>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/t4.png" alt="t4.png">
</div>
<div class="title">Figure 2. Add reference to .ttinclude file</div>
</div>
<div class="paragraph">
<p>Using DB first EF and generating the model from the existing schema uses a t4 template, <code>model1.tt</code> by default.</p>
</div>
<div class="paragraph">
<p>The <code>.ttinclude</code> file can be added to the top of this template and every model class that is generated will include the new content you define.</p>
</div>
<div class="listingblock">
<div class="title">RenderInterfaces template method</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+void Render_Interfaces(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){
var members = ((EntityType)entity).DeclaredProperties;

var pk = entity.KeyMembers.Any(k=&gt;k.Name.EndsWith("SeqID"));
var hasEE = members.Any(m=&gt;m.Name=="EffectiveEndDate");
var hasES = members.Any(m=&gt;m.Name=="EffectiveStartDate");
var hasStatusID = members.Any(m=&gt;m.Name=="StatusID");

#&gt;
:IClonable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+if(hasEE &amp;&amp; hasES){#&gt;, IVersionable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+}#&gt;&lt;#+if(pk &amp;&amp; hasEE &amp;&amp; hasES &amp;&amp; hasStatusID){#&gt;, IStatusEntity&lt;#+}#&gt;
&lt;#+}#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Render_Interfaces</code> method checks for specific columns/properties on the model and if they exist (<code>SeqID</code>, <code>EffectiveEndDate</code> &amp; <code>EffectiveStartDate</code>) then the generated class should have the interfaces <code>IVersionable&lt;T&gt;</code> &amp; <code>IClonable&lt;T&gt;</code></p>
</div>
<div class="listingblock">
<div class="title">Adding the <code>Render_Interfaces</code> method to the Model1.tt file</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#=codeStringGenerator.EntityClassOpening(entity)#&gt; &lt;#this.Render_Interfaces(entity);#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second method in the <code>.ttinclude</code> template is the one that adds the <code>Clone</code> and <code>Update</code> methods.</p>
</div>
<div class="listingblock">
<div class="title"><code>Clone</code> and <code>Update</code> method templates</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+
void Render_Methods(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){

/// &lt;summary&gt;
/// Creates a shallow copy of the &lt;#=entity.Name #&gt;
/// Only copies primative types, should not copy primary keys
/// &lt;/summary&gt;
/// &lt;returns&gt;A new clone&lt;/returns&gt;
public &lt;#=entity.Name #&gt; Clone(){
	return new &lt;#= entity.Name #&gt;{
    &lt;#+
    for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){
		#&gt;
&lt;#=members[i].Name#&gt; = &lt;#=members[i].Name#&gt;,
	&lt;#+}
    }#&gt;
    };
}

/// &lt;summary&gt;
/// Updates the &lt;#=entity.Name #&gt; with values from the source
/// Only updates primative types, should not update primary keys
/// &lt;/summary&gt;
public void Update(&lt;#=entity.Name #&gt; source){
    &lt;#+for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){#&gt;
		this.&lt;#=members[i].Name#&gt; = source.&lt;#=members[i].Name#&gt;;
	&lt;#+}
    }#&gt;
}</code></pre>
</div>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/render.png" alt="render.png">
</div>
<div class="title">Figure 3. Calling the <code>Render_Methods</code> helper method</div>
</div>
<div class="paragraph">
<p>The result of updating the interfaces and adding the <code>Clone</code> &amp; <code>Update</code> methods at the start of the class template looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">public partial class Employee :IClonable&lt;Employee&gt;, IVersionable&lt;Employee&gt;{
/*
    Template debug info
    ---------------------
    Has PK ending with 'SeqID' : True
    Has EE : True
    Has ES : True
    Has Status : False
    */


/// &lt;summary&gt;
/// Creates a shallow copy of the Employee
    /// Only copies primative types, should not copy primary keys
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A new clone&lt;/returns&gt;
    public Employee Clone(){
    	return new Employee{
        EID = EID,
    	PartyID = PartyID,
    	PreferredRoleID = PreferredRoleID,
    	AccessExpiryDate = AccessExpiryDate,
    	EffectiveStartDate = EffectiveStartDate,
    	EffectiveEndDate = EffectiveEndDate,
    	    };
    }

    /// &lt;summary&gt;
    /// Updates the Employee with values from the source
    /// Only updates primative types, should not update primary keys
    /// &lt;/summary&gt;
    public void Update(Employee source){
        this.EID = source.EID;
    	this.PartyID = source.PartyID;
    	this.PreferredRoleID = source.PreferredRoleID;
    	this.AccessExpiryDate = source.AccessExpiryDate;
    	this.EffectiveStartDate = source.EffectiveStartDate;
    	this.EffectiveEndDate = source.EffectiveEndDate;
    	}


    public int SeqId{
    	get{
    	return EmployeePartySeqID;
    	}
    	set{
    	EmployeePartySeqID = value;
    	}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Customizing the generated templates is pretty simple once you get the hang of the default template. I definitely prefer a code first approach, unfortunately that wasn&#8217;t an option on this project. While having to work with the <code>edmx</code> isn&#8217;t my preference, it is useful to know how to fine tune the models if needs be.</p>
</div>]]></description><link>https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</guid><category><![CDATA[C#]]></category><category><![CDATA[ T4]]></category><category><![CDATA[ EF]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 07 Mar 2017 00:00:00 GMT</pubDate></item></channel></rss>