<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Untitled RSS Feed]]></title><description><![CDATA[Untitled RSS Feed]]></description><link>https://dannylane.github.io</link><image><url>https://github.com/dannylane/dannylane.github.io/raw/master/images/zoom.png</url><title>Untitled RSS Feed</title><link>https://dannylane.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Tue, 07 Mar 2017 23:11:33 GMT</lastBuildDate><atom:link href="https://dannylane.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Continous Integration Testing with TFS Build 2013, NUnit and SQL Server Database dacpacs]]></title><description><![CDATA[<div class="paragraph">
<p>I spent some time recently working on a .NET project where the DB schema was put in place before application development began. The schema was complex, simple entities were spread across multiple tables, there were requirements around maintaining in-table historical versions of almost all records. There were very few simple insert/updates in the application, all DB actions became a series of versioning records and realigning historical records to maintain historical integrity.</p>
</div>
<div class="paragraph">
<p>It quickly became apparent that the DB access code was going to be an area of high risk and that we should take steps to mitigate that risk by including the DB interaction in our automated tests.<br>
I have a strong preference for unit tests over integration tests, I like to mock the elements that are outside the boundary of my control. It&#8217;s good to test how an application responds to external failures, like an unavailable service or a DB timeout, but you need to be able to assume that the services you consume or the DB technology you are building on is reasonably reliable. I like the image of the testing pyramid that puts the focus on unit tests, some integration tests and a few end to end tests.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html"><img src="https://2.bp.blogspot.com/-YTzv_O4TnkA/VTgexlumP1I/AAAAAAAAAJ8/57-rnwyvP6g/s1600/image02.png" alt="triangle" width="200" height="200"></a>
</div>
</div>
<div class="paragraph">
<p>The risk for this project was that we needed to be sure that we were persisting our data in a predictable manner, we needed to verify we weren&#8217;t loosing information among all the versioning madness that was going on.</p>
</div>
<div class="paragraph">
<p>When I joined the project there were a few unit and integration tests in place. The test weren&#8217;t run in a CI build (there was no build yet, it was early enough in the project) so when I ran the tests on day 1 they all failed. The integration tests were going to the development database, none of them were setting up their own data and there was no cleanup/tear-down happening. 2 test runs at the same time would most likely fail.</p>
</div>
<div class="paragraph">
<p>I strongly felt that the integration tests should be spinning up an instance of the DB schema, prepopulating data, executing the tests and then cleaning up the db. I believed facilitating this flow of testing in the project would greatly reduce the potential for errors around the db code.</p>
</div>
<div class="paragraph">
<p>There was a SQL Server Database project used to manage the schema but the schema was in one big drop/create script instead of the desired state folder structure like below.<br>
It was my first time working with a DB project like this and I found it incredibly useful.<br>
It takes most of the pain out of deploying schema changes, you still need to be able to handle data migrations but I&#8217;ll talk about that another day.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/ci/1.project.png" alt="1.project.png">
</div>
<div class="title">Figure 1. DB project structure</div>
</div>
<div class="paragraph">
<p>The build artifact produced by the DB project is a dacpac file. The dacpac includes some manual scripts that we use to prepopulate a new DB with setup/reference data. Deploying the dacpac before the integration test will also give us test data to work with in our tests.</p>
</div>
<div class="paragraph">
<p>I setup an <code>IntegrationTestSetUp</code> class that has the <code>[SetUpFixture]</code> attribute from <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">nunit</a></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>A SetUpFixture outside of any namespace provides SetUp and TearDown for the entire assembly.</p>
</div>
</blockquote>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/ci/2.setupfixture.png" alt="2.setupfixture.png">
</div>
<div class="title">Figure 2. <code>SetUpFixture</code> per class library</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/ci/3.setup.png" alt="3.setup.png">
</div>
<div class="title">Figure 3. <code>SetUp</code> method runs once per class library</div>
</div>
<div class="paragraph">
<p>The setup method deployed a version of the dacpac to the localdb server.</p>
</div>
<div class="paragraph">
<p>The code for deploying the dacpac looks like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">private const string ConnectionStringFormat = "data source=(localdb)\\MSSQLLocalDB;Integrated Security=True;Connection Timeout=60;Database={0}";

private static void DeployDacpac(string databaseName)
{
    var start = DateTime.UtcNow;

    var path = AppDomain.CurrentDomain.BaseDirectory + "\\..\\..\\..\\..\\DDS.Database\\bin\\Output\\DDS.Database.dacpac";

    // The dacpac is in a different location on the build server.
    if (!File.Exists(path))
    {
        path = AppDomain.CurrentDomain.BaseDirectory + "\\DDS.Database.dacpac";
    }
    try
    {
        var service = new DacServices(GetConnectionString(databaseName));
        service.Message += (sender, args) =&gt; log.Debug(args.Message); //Console.WriteLine(args.Message);
        service.ProgressChanged += (sender, args) =&gt; log.Debug(args.Message);//Console.WriteLine(args.Message);
        var dacpac = DacPackage.Load(path);
        var ddo = new DacDeployOptions
                {
                    BlockOnPossibleDataLoss = false,
                    CreateNewDatabase = true
                };
        ddo.SqlCommandVariableValues.Add("DeploymentEnvironment", "IntegrationTest");
        service.Deploy(dacpac, databaseName, true, ddo);
    }
       catch (Exception ex)
            {
                log.Debug(String.Format(ex.Message));
                log.Debug(String.Format(ex.InnerException != null ? ex.InnerException.Message : "No inner exception"));
            }

        log.Debug(String.Format("DB spin up in " + DateTime.UtcNow.Subtract(start).Seconds));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DacServices</code> class is used to deploy the dacpac.</p>
</div>
<div class="paragraph">
<p>The connection string was generated randomly for each assembly so that all the tests within an assembly would be using a dedicated DB.<br>
It would have been easy to make the DB spin up and down per test but that would have slowed the builds considerably.</p>
</div>
<div class="paragraph">
<p>This <code>IntegrationSetUp</code> class was linked to all other integration test projects so that the code didn&#8217;t need to be duplicated, it was written once and then linked to the other projects.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/ci/5.linkedsetup.png" alt="5.linkedsetup.png">
</div>
<div class="title">Figure 4. The <code>IntegrationSetUp</code> is a linked file in the test projects.</div>
</div>
<div class="paragraph">
<p>The tear down method deleted the db:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#"> private const string DropDatabaseCommand = "USE master " +
                                           "IF DB_ID('{0}') IS NOT NULL " +
                                           "BEGIN " +
                                           "ALTER DATABASE {0} SET SINGLE_USER WITH ROLLBACK IMMEDIATE " +
                                           "DROP DATABASE {0} " +
                                           "END";

        private static void DropDatabase(string connectionString, string databaseName)
        {
            int result;
            log.Debug(String.Format("Dropping database {0}", databaseName));
            using (var connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (var cmd = new SqlCommand(string.Format(DropDatabaseCommand, databaseName), connection))
                {
                    result = cmd.ExecuteNonQuery();
                }
            }
            log.Debug(String.Format("Dropped database {0}. {1}", databaseName, result));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>I also wrote a base test class that allowed developers to setup SQL scripts for inserting data that is specific to the test they are working on. This allows us to isolate data that will be  manipulated by a test from impacting on other test data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">public abstract class IntegrationTestBase

        [TestFixtureSetUp]
        public void SetUp()
        {
            TestLogSetup.Logger();
            RunManualScripts();
            RunOptionalScript();
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The optional script per test fixture relied on a convention where the name of the sql file to be run matches the name of the test fixture class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">        protected void RunOptionalScript()
        {
            var thisType = GetType();
            var path = string.Format(@"{0}\{2}.Scripts\{1}.sql", AppDomain.CurrentDomain.BaseDirectory, thisType.Name, thisType.Assembly.GetName().Name);
            RunScriptFromPath(path);
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We had 4 integration test libraries so on each build 4 different DBs would be provisioned.</p>
</div>
<div class="paragraph">
<p>Having the tests setup like this allowed us a lot of flexibility when writing our integration tests, most importantly it became easy for the team to write the tests in a reproducible manner and abstracted away all the heavy lifting that needed to be done around the DB setups.</p>
</div>
<div class="paragraph">
<p>Having such a reliance on integration tests like this isn&#8217;t something I&#8217;d like to use again but it&#8217;s nice to know the option exists if I need it.</p>
</div>]]></description><link>https://dannylane.github.io/2017/03/07/Continous-Integration-Testing-with-TFS-Build-2013-N-Uit-and-SQL-Server-Database-dacpacs.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/07/Continous-Integration-Testing-with-TFS-Build-2013-N-Uit-and-SQL-Server-Database-dacpacs.html</guid><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 07 Mar 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Extending EntityFramework Generated Model Classes With T4 Templates]]></title><description><![CDATA[<div class="paragraph">
<p>I was working on a project recently where we used a common pattern for versioning DB records. Extending the EF generated model classes made it easier for the team to apply the pattern consistently.<br>
I updated the generated code to render a generic interface if specific properties exist on the model. 2 helper methods (<code>Clone</code> &amp; <code>Update</code>) were added to the models and were regenerated whenever the model was refreshed.</p>
</div>
<div id="img-project" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/project.png" alt="project.png">
</div>
<div class="title">Figure 1. EnttityVersion.ttinclude</div>
</div>
<div class="paragraph">
<p>I added new templating content as methods exposed in a <code>.ttinclude</code> file.</p>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/t4.png" alt="t4.png">
</div>
<div class="title">Figure 2. Add reference to .ttinclude file</div>
</div>
<div class="paragraph">
<p>Using DB first EF and generating the model from the existing schema uses a t4 template, <code>model1.tt</code> by default.</p>
</div>
<div class="paragraph">
<p>The <code>.ttinclude</code> file can be added to the top of this template and every model class that is generated will include the new content you define.</p>
</div>
<div class="listingblock">
<div class="title">RenderInterfaces template method</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+void Render_Interfaces(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){
var members = ((EntityType)entity).DeclaredProperties;

var pk = entity.KeyMembers.Any(k=&gt;k.Name.EndsWith("SeqID"));
var hasEE = members.Any(m=&gt;m.Name=="EffectiveEndDate");
var hasES = members.Any(m=&gt;m.Name=="EffectiveStartDate");
var hasStatusID = members.Any(m=&gt;m.Name=="StatusID");

#&gt;
:IClonable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+if(hasEE &amp;&amp; hasES){#&gt;, IVersionable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+}#&gt;&lt;#+if(pk &amp;&amp; hasEE &amp;&amp; hasES &amp;&amp; hasStatusID){#&gt;, IStatusEntity&lt;#+}#&gt;
&lt;#+}#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Render_Interfaces</code> method checks for specific columns/properties on the model and if they exist (<code>SeqID</code>, <code>EffectiveEndDate</code> &amp; <code>EffectiveStartDate</code>) then the generated class should have the interfaces <code>IVersionable&lt;T&gt;</code> &amp; <code>IClonable&lt;T&gt;</code></p>
</div>
<div class="listingblock">
<div class="title">Adding the <code>Render_Interfaces</code> method to the Model1.tt file</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#=codeStringGenerator.EntityClassOpening(entity)#&gt; &lt;#this.Render_Interfaces(entity);#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second method in the <code>.ttinclude</code> template is the one that adds the <code>Clone</code> and <code>Update</code> methods.</p>
</div>
<div class="listingblock">
<div class="title"><code>Clone</code> and <code>Update</code> method templates</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+
void Render_Methods(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){

/// &lt;summary&gt;
/// Creates a shallow copy of the &lt;#=entity.Name #&gt;
/// Only copies primative types, should not copy primary keys
/// &lt;/summary&gt;
/// &lt;returns&gt;A new clone&lt;/returns&gt;
public &lt;#=entity.Name #&gt; Clone(){
	return new &lt;#= entity.Name #&gt;{
    &lt;#+
    for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){
		#&gt;
&lt;#=members[i].Name#&gt; = &lt;#=members[i].Name#&gt;,
	&lt;#+}
    }#&gt;
    };
}

/// &lt;summary&gt;
/// Updates the &lt;#=entity.Name #&gt; with values from the source
/// Only updates primative types, should not update primary keys
/// &lt;/summary&gt;
public void Update(&lt;#=entity.Name #&gt; source){
    &lt;#+for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){#&gt;
		this.&lt;#=members[i].Name#&gt; = source.&lt;#=members[i].Name#&gt;;
	&lt;#+}
    }#&gt;
}</code></pre>
</div>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/render.png" alt="render.png">
</div>
<div class="title">Figure 3. Calling the <code>Render_Methods</code> helper method</div>
</div>
<div class="paragraph">
<p>The result of updating the interfaces and adding the <code>Clone</code> &amp; <code>Update</code> methods at the start of the class template looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">public partial class Employee :IClonable&lt;Employee&gt;, IVersionable&lt;Employee&gt;{
/*
    Template debug info
    ---------------------
    Has PK ending with 'SeqID' : True
    Has EE : True
    Has ES : True
    Has Status : False
    */


/// &lt;summary&gt;
/// Creates a shallow copy of the Employee
    /// Only copies primative types, should not copy primary keys
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A new clone&lt;/returns&gt;
    public Employee Clone(){
    	return new Employee{
        EID = EID,
    	PartyID = PartyID,
    	PreferredRoleID = PreferredRoleID,
    	AccessExpiryDate = AccessExpiryDate,
    	EffectiveStartDate = EffectiveStartDate,
    	EffectiveEndDate = EffectiveEndDate,
    	    };
    }

    /// &lt;summary&gt;
    /// Updates the Employee with values from the source
    /// Only updates primative types, should not update primary keys
    /// &lt;/summary&gt;
    public void Update(Employee source){
        this.EID = source.EID;
    	this.PartyID = source.PartyID;
    	this.PreferredRoleID = source.PreferredRoleID;
    	this.AccessExpiryDate = source.AccessExpiryDate;
    	this.EffectiveStartDate = source.EffectiveStartDate;
    	this.EffectiveEndDate = source.EffectiveEndDate;
    	}


    public int SeqId{
    	get{
    	return EmployeePartySeqID;
    	}
    	set{
    	EmployeePartySeqID = value;
    	}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Customizing the generated templates is pretty simple once you get the hang of the default template. I definitely prefer a code first approach, unfortunately that wasn&#8217;t an option on this project. While having to work with the <code>edmx</code> isn&#8217;t my preference, it is useful to know how to fine tune the models if needs be.</p>
</div>]]></description><link>https://dannylane.github.io/2017/02/28/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/02/28/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</guid><category><![CDATA[C#]]></category><category><![CDATA[ T4]]></category><category><![CDATA[ EF]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 28 Feb 2017 00:00:00 GMT</pubDate></item></channel></rss>