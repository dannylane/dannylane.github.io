<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Danny Lane]]></title><description><![CDATA[Notes To _Self]]></description><link>https://dannylane.github.io</link><image><url>https://github.com/dannylane/dannylane.github.io/raw/master/images/zoom.png</url><title>Danny Lane</title><link>https://dannylane.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Fri, 10 Mar 2017 21:24:22 GMT</lastBuildDate><atom:link href="https://dannylane.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Troubleshooting TFS DB Growth]]></title><description><![CDATA[<div class="paragraph">
<p><strong>Spoiler:</strong> This was caused by ReleaseManager 2013 retaining builds. Read on for the work around that was put in place.</p>
</div>
<div class="paragraph">
<p>As part of a project I was working on recently; I put in a lot of work around TFS Builds, Unit/Integration Tests &amp; continous delivery using ReleaseManager.</p>
</div>
<div class="paragraph">
<p>It was a fairly standard pipeline:<br>
→ Checkin → Unit &amp; Integration Tests Run → Build → Release To Test</p>
</div>
<div class="paragraph">
<p>Up until this project the TFS Build hadn&#8217;t been used, TFS was just used for source control and some workitem tracking, it was hosted on a VM and didn&#8217;t take up much apce <strong><strong></strong></strong>**TODO The DB for TFS was a SQL express on the TFS VM (it has since been moved off to a physical server with DR)</p>
</div>
<div class="paragraph">
<p>After a few months of the project I started getting reports that the TFS VM size was growing constantly. IT had to increase the disk size on the VMs a couple of times.</p>
</div>
<div class="paragraph">
<p>It turns out that the VM had grown from ***TODO</p>
</div>
<div class="paragraph">
<p>After doing a little research online I found the following query that gives some insight into which tables are taking up the most space in the db.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">USE Tfs_DefaultCollection

SELECT
    t.NAME AS TableName,
    s.Name AS SchemaName,
    p.rows AS RowCounts,
    SUM(a.total_pages) * 8 AS TotalSpaceKB,
    SUM(a.used_pages) * 8 AS UsedSpaceKB,
    (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB
FROM
    sys.tables t
INNER JOIN
    sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN
    sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN
    sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN
    sys.schemas s ON t.schema_id = s.schema_id
GROUP BY
    t.Name, s.Name, p.Rows
ORDER BY
    TotalSpaceKB desc</code></pre>
</div>
</div>
<div class="paragraph">
<p>**TODO table with high storage &amp; explanation</p>
</div>
<div class="paragraph">
<p>Normally TFS retains builds as defined by a build retention policy, ours tells it to only keep the last 10 builds.<br>
However, there is a known issue with the Microsoft Release Management 2013 that causes every build that is involved in a release to be retained indefinitely, this doesn&#8217;t really fit with the continous delivery model and has been changed in newer versions.<br>
Every check in we do triggers a build which triggers a release so all our builds are retained.</p>
</div>
<div class="paragraph">
<p>This has issues for the storage capacity on the drops folder where builds are dropped and also storage capacity in the database.</p>
</div>
<div class="paragraph">
<p>The issue was exacerbated for this project because of the logging setup in the integration tests. Each test class library gets a DB deployed and dropped and seed scripts run, all the logging from these activities is echoed to the console. The application logging is also set to console output.<br>
All this log info for each test run is stored in the TFS database which grew unmanageably.<br>
The logging was turned off on the automated builds so this should help keep the size down for newer builds</p>
</div>
<div class="ulist">
<ul>
<li>
<p>todo logmanager stuff for builds</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To manage the retained builds I wrote a powershell script that does the following steps for every build older than 2 weeks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Update the Retain Indefinitely flag to false</p>
</li>
<li>
<p>Delete the build</p>
</li>
<li>
<p>Destroy the build</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Delete the build</strong><br>
This is what is available through the UI, it is only a logical delete and while it does delete artifacts from the network drop folders, it does not delete rows from the db</p>
</div>
<div class="paragraph">
<p><strong>Destroy the build</strong><br>
This is the delete from the db. This is not available though the UI and is only available through the API</p>
</div>
<div class="paragraph">
<p>I setup a build in TFS that runs at 3am every day and runs this scripts as part of the build.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">param ($serverName = 'http://&lt;snip&gt;:8080/tfs/DefaultCollection')

[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Client")
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Build.Client")
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.VersionControl.Client")
$tfs = [Microsoft.TeamFoundation.Client.TeamFoundationServerFactory]::GetServer($serverName)

$buildServer =  $tfs.GetService([Microsoft.TeamFoundation.Build.Client.IBuildServer])
$vcs =  $tfs.GetService([Microsoft.TeamFoundation.VersionControl.Client.VersionControlServer])

$projects = $vcs.GetAllTeamProjects($true) # We will run this for all team projects

foreach ($project in $projects){
    Write-Host $project.Name

    # Get all the build definitions for a given project
    $buildDefs = $buildServer.QueryBuildDefinitions($project.Name)

    foreach ($buildDef in $buildDefs){
        Write-Host "-" + $buildDef.Name
        # Delete all builds older than 14 days. This is a bit aggressive and can be pushed to a month once the logs are smaller on automated builds.
        $endDate = (Get-Date).AddDays(-14)
        # Keep going back until we hit dec 2014
        while($endDate.Year -ge 2014){
            $year = $endDate.Year
            $month = $endDate.Month
            write-host $year $month
            # Create a search object for the project/build def
            $buildDetailSpec = $buildServer.CreateBuildDetailSpec($project.Name, $buildDef.Name)
            $startDate = $endDate.addMonths(-1)
            $buildDetailSpec.MaxFinishTime = $endDate # Search criteria
            $buildDetailSpec.MinFinishTime = $startDate # Search criteria
            # only build info, not workitems, labels, etc
            $buildDetailSpec.InformationTypes = $null

            ## This is important for the query, builds that are deletd by retention
            ## or the ui are only logically deleted, not destroyed in the db
            $buildDetailSpec.QueryDeletedOption = [Microsoft.TeamFoundation.Build.Client.QueryDeletedOption]::IncludeDeleted

            # Search all the things
            $builds = $buildServer.QueryBuilds($buildDetailSpec)
            if($builds.Builds.Length -ge 1){
                Write-Host "before update" $builds.Builds
                foreach($build in $builds.Builds){
                    # Need to turn off the Keep Forever (Retain) flag set by Release Manager.
                    if ($build.KeepForever -eq $true){
                        Write-Host "Updating build " $build.Uri
                        # Gets an updatable ref to the build
                        $buildToEdit = $buildServer.GetBuild($build.Uri)
                        # Edit the build flag
                        $buildToEdit.KeepForever = $false;
                        # save the build back to the tfs
                        $buildServer.SaveBuilds(@($buildToEdit))
                    }
                }
                # refresh the query given that some of the builds have been updated
                $builds = $buildServer.QueryBuilds($buildDetailSpec)
                Write-Host "after refresh" $builds.Builds
                # Delete the build, test results, symbols, drop, etc.
                $buildServer.DeleteBuilds($builds.Builds,
                [Microsoft.TeamFoundation.Build.Client.DeleteOptions]::All)
                # Destroy the db records
                $buildServer.DestroyBuilds($builds.Builds)
            }
            # rolling back the years.
            $endDate = $endDate.addMonths(-1)
        }
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TableName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SchemaName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RowCounts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TotalSpaceKB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UsedSpaceKB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UnusedSpaceKB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">69733</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1889136</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1869000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20136</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_TestResult</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">174868</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">323192</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">321504</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1688</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_LocalVersion</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">413449</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">122072</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">120048</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2024</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_BuildCodeChange</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">148950</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78016</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">77824</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">192</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">101484</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">68872</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">68544</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">328</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_BuildInformation2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">88673</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64232</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">63512</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">720</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dbo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">92974</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39192</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">38928</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">264</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p> You can see the output from the script in the Diagnostics tab from the build:
 This is where the script is configured:<br>
++ This is the build trigger:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/buildpurge/dummyproject.png" alt="dummyproject.png">
</div>
</div>]]></description><link>https://dannylane.github.io/2017/03/14/Troubleshooting-TFS-DB-Growth.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/14/Troubleshooting-TFS-DB-Growth.html</guid><category><![CDATA[TFS]]></category><category><![CDATA[ ReleaseManager]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 14 Mar 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Extending EntityFramework Generated Model Classes With T4 Templates]]></title><description><![CDATA[<div class="paragraph">
<p>I was working on a project recently where we used a common pattern for versioning DB records. Extending the EF generated model classes made it easier for the team to apply the pattern consistently.<br>
I updated the generated code to render a generic interface if specific properties exist on the model. 2 helper methods (<code>Clone</code> &amp; <code>Update</code>) were added to the models and were regenerated whenever the model was refreshed.</p>
</div>
<div id="img-project" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/project.png" alt="project.png">
</div>
<div class="title">Figure 1. EnttityVersion.ttinclude</div>
</div>
<div class="paragraph">
<p>I added new templating content as methods exposed in a <code>.ttinclude</code> file.</p>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/t4.png" alt="t4.png">
</div>
<div class="title">Figure 2. Add reference to .ttinclude file</div>
</div>
<div class="paragraph">
<p>Using DB first EF and generating the model from the existing schema uses a t4 template, <code>model1.tt</code> by default.</p>
</div>
<div class="paragraph">
<p>The <code>.ttinclude</code> file can be added to the top of this template and every model class that is generated will include the new content you define.</p>
</div>
<div class="listingblock">
<div class="title">RenderInterfaces template method</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+void Render_Interfaces(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){
var members = ((EntityType)entity).DeclaredProperties;

var pk = entity.KeyMembers.Any(k=&gt;k.Name.EndsWith("SeqID"));
var hasEE = members.Any(m=&gt;m.Name=="EffectiveEndDate");
var hasES = members.Any(m=&gt;m.Name=="EffectiveStartDate");
var hasStatusID = members.Any(m=&gt;m.Name=="StatusID");

#&gt;
:IClonable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+if(hasEE &amp;&amp; hasES){#&gt;, IVersionable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+}#&gt;&lt;#+if(pk &amp;&amp; hasEE &amp;&amp; hasES &amp;&amp; hasStatusID){#&gt;, IStatusEntity&lt;#+}#&gt;
&lt;#+}#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Render_Interfaces</code> method checks for specific columns/properties on the model and if they exist (<code>SeqID</code>, <code>EffectiveEndDate</code> &amp; <code>EffectiveStartDate</code>) then the generated class should have the interfaces <code>IVersionable&lt;T&gt;</code> &amp; <code>IClonable&lt;T&gt;</code></p>
</div>
<div class="listingblock">
<div class="title">Adding the <code>Render_Interfaces</code> method to the Model1.tt file</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#=codeStringGenerator.EntityClassOpening(entity)#&gt; &lt;#this.Render_Interfaces(entity);#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second method in the <code>.ttinclude</code> template is the one that adds the <code>Clone</code> and <code>Update</code> methods.</p>
</div>
<div class="listingblock">
<div class="title"><code>Clone</code> and <code>Update</code> method templates</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+
void Render_Methods(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){

/// &lt;summary&gt;
/// Creates a shallow copy of the &lt;#=entity.Name #&gt;
/// Only copies primative types, should not copy primary keys
/// &lt;/summary&gt;
/// &lt;returns&gt;A new clone&lt;/returns&gt;
public &lt;#=entity.Name #&gt; Clone(){
	return new &lt;#= entity.Name #&gt;{
    &lt;#+
    for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){
		#&gt;
&lt;#=members[i].Name#&gt; = &lt;#=members[i].Name#&gt;,
	&lt;#+}
    }#&gt;
    };
}

/// &lt;summary&gt;
/// Updates the &lt;#=entity.Name #&gt; with values from the source
/// Only updates primative types, should not update primary keys
/// &lt;/summary&gt;
public void Update(&lt;#=entity.Name #&gt; source){
    &lt;#+for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){#&gt;
		this.&lt;#=members[i].Name#&gt; = source.&lt;#=members[i].Name#&gt;;
	&lt;#+}
    }#&gt;
}</code></pre>
</div>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/render.png" alt="render.png">
</div>
<div class="title">Figure 3. Calling the <code>Render_Methods</code> helper method</div>
</div>
<div class="paragraph">
<p>The result of updating the interfaces and adding the <code>Clone</code> &amp; <code>Update</code> methods at the start of the class template looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">public partial class Employee :IClonable&lt;Employee&gt;, IVersionable&lt;Employee&gt;{
/*
    Template debug info
    ---------------------
    Has PK ending with 'SeqID' : True
    Has EE : True
    Has ES : True
    Has Status : False
    */


/// &lt;summary&gt;
/// Creates a shallow copy of the Employee
    /// Only copies primative types, should not copy primary keys
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A new clone&lt;/returns&gt;
    public Employee Clone(){
    	return new Employee{
        EID = EID,
    	PartyID = PartyID,
    	PreferredRoleID = PreferredRoleID,
    	AccessExpiryDate = AccessExpiryDate,
    	EffectiveStartDate = EffectiveStartDate,
    	EffectiveEndDate = EffectiveEndDate,
    	    };
    }

    /// &lt;summary&gt;
    /// Updates the Employee with values from the source
    /// Only updates primative types, should not update primary keys
    /// &lt;/summary&gt;
    public void Update(Employee source){
        this.EID = source.EID;
    	this.PartyID = source.PartyID;
    	this.PreferredRoleID = source.PreferredRoleID;
    	this.AccessExpiryDate = source.AccessExpiryDate;
    	this.EffectiveStartDate = source.EffectiveStartDate;
    	this.EffectiveEndDate = source.EffectiveEndDate;
    	}


    public int SeqId{
    	get{
    	return EmployeePartySeqID;
    	}
    	set{
    	EmployeePartySeqID = value;
    	}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Customizing the generated templates is pretty simple once you get the hang of the default template. I definitely prefer a code first approach, unfortunately that wasn&#8217;t an option on this project. While having to work with the <code>edmx</code> isn&#8217;t my preference, it is useful to know how to fine tune the models if needs be.</p>
</div>]]></description><link>https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</guid><category><![CDATA[C#]]></category><category><![CDATA[ T4]]></category><category><![CDATA[ EF]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 07 Mar 2017 00:00:00 GMT</pubDate></item></channel></rss>