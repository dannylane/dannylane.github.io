<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Danny Lane]]></title><description><![CDATA[Notes To _Self]]></description><link>https://dannylane.github.io</link><image><url>https://github.com/dannylane/dannylane.github.io/raw/master/images/zoom.png</url><title>Danny Lane</title><link>https://dannylane.github.io</link></image><generator>RSS for Node</generator><lastBuildDate>Tue, 21 Mar 2017 22:48:20 GMT</lastBuildDate><atom:link href="https://dannylane.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Troubleshooting TFS DB Growth]]></title><description><![CDATA[<div class="paragraph">
<p><strong>Spoiler:</strong> This was caused by ReleaseManager 2013 retaining builds. Read on for the work around that was put in place.</p>
</div>
<div class="paragraph">
<p>As part of a project I was working on recently; I put in a lot of work around TFS Builds, Unit/Integration Tests &amp; continous delivery using ReleaseManager.</p>
</div>
<div class="paragraph">
<p>It was a fairly standard pipeline:<br>
→ Check in → Unit &amp; Integration Tests Run → Build → Release To Test</p>
</div>
<div class="paragraph">
<p>Up until this project TFS Build hadn&#8217;t been used, TFS was just used for source control and some workitem tracking, it was hosted on a VM and space was never an issue.</p>
</div>
<div class="paragraph">
<p>After a few months of the project I started getting reports that the TFS DB size was growing constantly. The IT team had to keep allocating more space to the disks used for storing the DB backups.</p>
</div>
<div class="paragraph">
<p>It turns out that the <code>Tfs_DefaultCollection</code> had grown from about 6GB to over 50GB and the growth was constant.</p>
</div>
<div class="paragraph">
<p>After doing a little research online I found the following query that gives some insight into which tables are taking up the most space in the db.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">USE Tfs_DefaultCollection

SELECT
    t.NAME AS TableName,
    s.Name AS SchemaName,
    p.rows AS RowCounts,
    SUM(a.total_pages) * 8 AS TotalSpaceKB,
    SUM(a.used_pages) * 8 AS UsedSpaceKB,
    (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB
FROM
    sys.tables t
INNER JOIN
    sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN
    sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN
    sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN
    sys.schemas s ON t.schema_id = s.schema_id
GROUP BY
    t.Name, s.Name, p.Rows
ORDER BY
    TotalSpaceKB desc</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Tables taking up the most space</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Table</th>
<th class="tableblock halign-left valign-top">Row Count</th>
<th class="tableblock halign-left valign-top">Size (GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_TestResult</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">367386</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">19.660805</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_TestMessageLogEntry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22354468</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.085457</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">62475</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.4598694</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_BuildInformation2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22736801</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7.6754837</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Normally TFS retains builds as defined by a build retention policy, ours tells it to only keep the last 10 builds.<br>
However, there is a known issue with the Microsoft Release Management 2013 that causes every build that is involved in a release to be retained indefinitely, this doesn&#8217;t really fit with the continous delivery model and has been changed in newer versions.<br>
Every check in we do triggers a build which triggers a release <strong>so all our builds are retained</strong>.</p>
</div>
<div class="paragraph">
<p>This has issues for the storage capacity on the drops folder where builds are dropped and also storage capacity in the database.</p>
</div>
<div class="paragraph">
<p>The issue was exacerbated for this project because of the logging setup in the integration tests. Each test class library gets a DB deployed and dropped and seed scripts run, all the logging from these activities is echoed to the console. The application logging is also set to console output.<br>
All this log info for each test run is stored in the TFS database which grew unmanageably.<br>
The logging was turned off on the automated builds so this should help keep the size down for newer builds</p>
</div>
<div class="listingblock">
<div class="title">The application logs are driven by a config file but for tests I set the logs to <code>ConsoleOut</code> in <code>[SetUpFixture]</code> as the log information is available for each Unit Test. When I realised that all the logging info was retained in the DB I replaced the <code>ConsoleOut</code> logger with a <code>NoOp</code> logger on the build server.</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">    public static class TestLogSetup
    {
        public static void Logger()
        {
            Console.WriteLine(Environment.MachineName);
            if (Environment.MachineName.Contains("&lt;ServerName&gt;"))
            {
                Console.WriteLine("No Op Logger");
                LogManager.Adapter = new Common.Logging.Simple.NoOpLoggerFactoryAdapter();
            }
            else
            {
                Console.WriteLine("Console Logger");
                LogManager.Adapter = new Common.Logging.Simple.ConsoleOutLoggerFactoryAdapter();
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To manage the retained builds I wrote a powershell script that does the following steps for every build older than 2 weeks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Update the Retain Indefinitely flag to false</p>
</li>
<li>
<p>Delete the build</p>
</li>
<li>
<p>Destroy the build</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Delete the build</strong><br>
This is what is available through the UI, it is only a logical delete and while it does delete artifacts from the network drop folders, it does not delete rows from the db</p>
</div>
<div class="paragraph">
<p><strong>Destroy the build</strong><br>
This is the delete from the db. This is not available though the UI and is only available through the API</p>
</div>
<div class="listingblock">
<div class="title">This is the script that I wrote to destroy the builds.</div>
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">param ($serverName = 'http://&lt;snip&gt;:8080/tfs/DefaultCollection')

[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Client")
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.Build.Client")
[void][System.Reflection.Assembly]::LoadWithPartialName("Microsoft.TeamFoundation.VersionControl.Client")
$tfs = [Microsoft.TeamFoundation.Client.TeamFoundationServerFactory]::GetServer($serverName)

$buildServer =  $tfs.GetService([Microsoft.TeamFoundation.Build.Client.IBuildServer])
$vcs =  $tfs.GetService([Microsoft.TeamFoundation.VersionControl.Client.VersionControlServer])

$projects = $vcs.GetAllTeamProjects($true) # We will run this for all team projects

foreach ($project in $projects){
    Write-Host $project.Name

    # Get all the build definitions for a given project
    $buildDefs = $buildServer.QueryBuildDefinitions($project.Name)

    foreach ($buildDef in $buildDefs){
        Write-Host "-" + $buildDef.Name
        # Delete all builds older than 14 days. This is a bit aggressive and can be pushed to a month once the logs are smaller on automated builds.
        $endDate = (Get-Date).AddDays(-14)
        # Keep going back until we hit dec 2014
        while($endDate.Year -ge 2014){
            $year = $endDate.Year
            $month = $endDate.Month
            write-host $year $month
            # Create a search object for the project/build def
            $buildDetailSpec = $buildServer.CreateBuildDetailSpec($project.Name, $buildDef.Name)
            $startDate = $endDate.addMonths(-1)
            $buildDetailSpec.MaxFinishTime = $endDate # Search criteria
            $buildDetailSpec.MinFinishTime = $startDate # Search criteria
            # only build info, not workitems, labels, etc
            $buildDetailSpec.InformationTypes = $null

            ## This is important for the query, builds that are deletd by retention
            ## or the ui are only logically deleted, not destroyed in the db
            $buildDetailSpec.QueryDeletedOption = [Microsoft.TeamFoundation.Build.Client.QueryDeletedOption]::IncludeDeleted

            # Search all the things
            $builds = $buildServer.QueryBuilds($buildDetailSpec)
            if($builds.Builds.Length -ge 1){
                Write-Host "before update" $builds.Builds
                foreach($build in $builds.Builds){
                    # Need to turn off the Keep Forever (Retain) flag set by Release Manager.
                    if ($build.KeepForever -eq $true){
                        Write-Host "Updating build " $build.Uri
                        # Gets an updatable ref to the build
                        $buildToEdit = $buildServer.GetBuild($build.Uri)
                        # Edit the build flag
                        $buildToEdit.KeepForever = $false;
                        # save the build back to the tfs
                        $buildServer.SaveBuilds(@($buildToEdit))
                    }
                }
                # refresh the query given that some of the builds have been updated
                $builds = $buildServer.QueryBuilds($buildDetailSpec)
                Write-Host "after refresh" $builds.Builds
                # Delete the build, test results, symbols, drop, etc.
                $buildServer.DeleteBuilds($builds.Builds,
                [Microsoft.TeamFoundation.Build.Client.DeleteOptions]::All)
                # Destroy the db records
                $buildServer.DestroyBuilds($builds.Builds)
            }
            # rolling back the years.
            $endDate = $endDate.addMonths(-1)
        }
    }
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/buildpurge/dummyproject.png" alt="dummyproject.png">
</div>
<div class="title">Figure 1. I added the script to a dummy project in source control.</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/buildpurge/schedule.png" alt="schedule.png">
</div>
<div class="title">Figure 2. This project was set to run every morning at 3am</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/buildpurge/script.png" alt="script.png">
</div>
<div class="title">Figure 3. The powershell script is set to run after the build</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/buildpurge/logs.png" alt="logs.png">
</div>
<div class="title">Figure 4. The output from the script is available in the diagnostics tab of the build info from TFS.</div>
</div>
<div class="paragraph">
<p>The script could have been set to run as a scheduled task somewhere but I liked the idea of having it run within TFS as it made it easy for the dev team to monitor.</p>
</div>
<div class="paragraph">
<p>The impact of destroying the old builds was significant.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Row Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Size (GB)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">69733</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.889136</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_TestResult</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">174868</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.323192</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_LocalVersion</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">413449</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.122072</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_BuildCodeChange</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">148950</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.078016</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">101484</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.068872</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_BuildInformation2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">88673</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.064232</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tbl_Command</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">92974</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.039192</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Tracking down the cause of the size increase was an interesting exercise, hopefully some of this detail may help someone else in future.</p>
</div>]]></description><link>https://dannylane.github.io/2017/03/22/Troubleshooting-TFS-DB-Growth.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/22/Troubleshooting-TFS-DB-Growth.html</guid><category><![CDATA[TFS]]></category><category><![CDATA[ ReleaseManager]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Wed, 22 Mar 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Getting Started With .NET Core Microservices Using Docker & VS Code on OSX]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;ve started working on some .NET Core microservices stuff and thought I&#8217;d outline the steps I took to get a basic instance of a .NET Core service up and running in Docker on OSX.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_install_net_core">Install .NET Core</h4>
<div class="paragraph">
<p>The full instructions are <a href="https://www.microsoft.com/net/core#macos">here</a><br>
First, install openssl using <a href="https://brew.sh/">Homebrew</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">brew update
brew install openssl
mkdir -p /usr/local/lib
ln -s /usr/local/opt/openssl/lib/libcrypto.1.0.0.dylib /usr/local/lib/
ln -s /usr/local/opt/openssl/lib/libssl.1.0.0.dylib /usr/local/lib/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Install the .NET Core SDK from the page above.</p>
</div>
<div class="paragraph">
<p>I had an issue after the install where the dotnet command wasn&#8217;t exposed on my path. Found the following fix on one of the github issue <a href="https://github.com/dotnet/cli/issues/2544#issuecomment-220248063">comments</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">ln -s /usr/local/share/dotnet/dotnet /usr/local/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some comments suggest it may be because I use <a href="http://ohmyz.sh/">oh-my-zsh</a>.</p>
</div>
<div class="paragraph">
<p>Once the sdk is setup successfully you can init a project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">mkdir dotnet-microservice
cd dotnet-microservice
dotnet new
dotnet restore
dotnet run</code></pre>
</div>
</div>
<div class="paragraph">
<p>That should produce a simple <code>Hello World</code> output:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/helloworld.png" alt="helloworld.png">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_install_vs_code">Install VS Code</h4>
<div class="paragraph">
<p>Now that we have the basic .NET Core app let&#8217;s install VS Code to use as our IDE. The OSX download is available at <a href="https://code.visualstudio.com/">code.visualstudio.com</a></p>
</div>
<div class="paragraph">
<p>We need to add some nuget packages to the project so the first step is adding the Nuget package manager.</p>
</div>
<div class="paragraph">
<p>Go to View &#8594; Extensions and search for Nuget, the Docker extension is also useful for adding docker commands to VS Code.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/nugetextension.png" alt="nugetextension.png">
</div>
</div>
<div class="paragraph">
<p>Once you have Nuget installed you can access Nuget commands in the command bar with F1:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/commandbar.png" alt="commandbar.png">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/KSubedi/net-core-project-manager/master/images/add.gif" alt="add.gif">
</div>
</div>
<div class="paragraph">
<p>I added Kestrel and a couple of MVC nuget packages, you can see the list in the <code>project.json</code> file further down.</p>
</div>
<div class="paragraph">
<p>Once you add a nuget package through the UI you will get prompted to restore (<code>dotnet restore</code> is the terminal command):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/vscoderestore.png" alt="vscoderestore.png">
</div>
</div>
<div class="sect4">
<h5 id="_some_code">Some Code</h5>
<div class="paragraph">
<p>A microservice will normally expose a RESTful interface, to serve as the host we add a <code>WebHostBuilder</code> to the main method. Kestrel is a lightweight web server included in .NET Core. The <code>Startup</code> class is passed to the web host and allows you to define routing, DI and other services. The <code>ConfigurationBuilder</code> can be used to compile config settings from different sources; file, args, env, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">        public static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");

            var config = new ConfigurationBuilder()
            .Build();

            var builder = new WebHostBuilder()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseConfiguration(config)
                .UseStartup&lt;Startup&gt;()
                .UseKestrel()
                .UseUrls("http://localhost:5000");

            var host = builder.Build();
            host.Run();
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Startup class here is pretty basic, I just went with the default routing provided out of the box by MVC. You can add different route patterns or you can use attribute based routing if desired.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvcCore();
        }
        public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory)
        {
            app.UseMvcWithDefaultRoute();
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller is a simple math function. Um, multiplication&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">    public class CalculatorController : Controller
    {
        public string Multiply(int first, int second)
        {
            return (first * second).ToString();
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>project.json</code> lists the dependancies. In the most recent version of .NET Core, these <code>.json</code> files get upgraded to <code>.csproj</code> files</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "version": "1.0.0-*",
  "buildOptions": {
    "debugType": "portable",
    "emitEntryPoint": true
  },
  "dependencies": {
    "Microsoft.AspNetCore.Server.Kestrel": "1.1.0",
    "Microsoft.AspNetCore.StaticFiles": "1.1.0",
    "Microsoft.AspNetCore.Routing": "1.1.0",
    "Microsoft.AspNetCore.Mvc.Core": "1.1.0",
    "Microsoft.AspNetCore.Mvc": "1.1.0"
  },
  "frameworks": {
    "netcoreapp1.1": {
      "dependencies": {
        "Microsoft.NETCore.App": {
          "type": "platform",
          "version": "1.1.0"
        }
      },
      "imports": "dnxcore50"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>dotnet run</code> you can start the server:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/curl.png" alt="curl.png">
</div>
</div>
<div class="paragraph">
<p>The debug mode of VS Code lets you debug the application as you would expect:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/debug.png" alt="debug.png">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_docker">Docker</h4>
<div class="paragraph">
<p>Now that we can run the service locally, lets add it to a docker container. The first step is to create a <code>dockerfile</code>. The Docker extension for VS Code has some commands built in:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/dockercommands.png" alt="dockercommands.png">
</div>
</div>
<div class="paragraph">
<p>This was the first version of my <code>dockerfile</code>, I&#8217;ll walk through some of the issues I had to troubleshoot further down.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dockerfile" data-lang="dockerfile">FROM microsoft/aspnetcore:1.0.1
LABEL Name=dotnet-microservice Version=0.0.1
ARG source=.
WORKDIR /app
EXPOSE 5000
COPY $source .
ENTRYPOINT dotnet dotnet-microservice.dll</code></pre>
</div>
</div>
<div class="paragraph">
<p>Building my docker file from VS Code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">docker build -f Dockerfile -t dotnet-microservice:latest .
Sending build context to Docker daemon 518.1 kB
Step 1/7 : FROM microsoft/aspnetcore:1.0.1
1.0.1: Pulling from microsoft/aspnetcore</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_base_image_vs_app_version_mismatch">Base image vs app version mismatch</h4>
<div class="paragraph">
<p>Running the docker container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">▶ docker run -it --rm dotnet-microservice:latest
The specified framework 'Microsoft.NETCore.App', version '1.1.0' was not found.
  - Check application dependencies and target a framework version installed at:
      /usr/share/dotnet/shared/Microsoft.NETCore.App
  - The following versions are installed:
      1.0.1
  - Alternatively, install the framework version '1.1.0'.</code></pre>
</div>
</div>
<div class="paragraph">
<p>My first issue was the incorrect version of my app compared to the aspnetcore version I pulled down in my base image.</p>
</div>
<div class="paragraph">
<p>I updated the base image in the dockerfile and rebuilt:
<code>FROM microsoft/aspnetcore:1.1.0</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_copying_the_correct_folder">Copying the correct folder</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">▶ docker run -it --rm dotnet-microservice:latest
Did you mean to run dotnet SDK commands? Please install dotnet SDK from:
  http://go.microsoft.com/fwlink/?LinkID=798306&amp;clcid=0x409</code></pre>
</div>
</div>
<div class="paragraph">
<p>The issue this time turned out to be the <code>COPY</code> command wasn&#8217;t copying my build output to the working dir of the image.</p>
</div>
<div class="paragraph">
<p><code>COPY $source/bin/Debug/netcoreapp1.1/ .</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_publishing_artifacts">Publishing artifacts</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">docker run -it --rm dotnet-microservice:latest
Error: assembly specified in the dependencies manifest was not found -- package:
'Microsoft.DotNet.PlatformAbstractions', version: '1.1.0', path: 'lib/netstandard
1.3/Microsoft.DotNet.PlatformAbstractions.dll'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time I realized I was copying the <code>build</code> output but I needed to be running a <code>publish</code> so that dependencies are included. I needed to run <code>dotnet publish</code> and change the <code>COPY</code> to pick up the published output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">▶ dotnet publish
Publishing dotnet-microservice for .NETCoreApp,Version=v1.1
Project dotnet-microservice (.NETCoreApp,Version=v1.1) was previously compiled. S
kipping compilation.
publish: Published to /Users/danny/dev/dotnet-microservice/bin/Debug/netcoreapp1.
1/publish
Published 1/1 projects successfully</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>COPY $source/bin/Debug/netcoreapp1.1/publish .</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_port_forwarding">Port forwarding</h4>
<div class="paragraph">
<p>The <code>publish</code> did the trick, now I was able to run the docker container&#8230;&#8203; but not access the endpoint.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">▶ docker run -it --rm dotnet-microservice:latest
Hello World!
Hosting environment: Production
Content root path: /app
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.</code></pre>
</div>
</div>
<div class="paragraph">
<p>I ran the docker container specifying <code>*</code> as the host to bind to and forwarding port 5000 on the container to post 5001 on my machine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">▶ docker run -p 5001:5000 dotnet-microservice
Hello World!
Hosting environment: Production
Content root path: /app
Now listening on: http://*:5000
Application started. Press Ctrl+C to shut down.</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/curl2.png" alt="curl2.png">
</div>
</div>
<div class="paragraph">
<p>Curl confirms that there is nothing running on port 5000 and the container is exposed on port 5001.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/dotnetcore/dockerps.png" alt="dockerps.png">
</div>
</div>
<div class="paragraph">
<p>The <code>docker ps</code> command lists the running containers</p>
</div>
<div class="paragraph">
<p>That&#8217;s it, a simple microservice running on the .NET Core Kestrel server and packaged up in a docker image. It&#8217;s a basic structure for somethign that can be built upon in future.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve included the terminal commands/output just in case others hit similar issues and hopefully the solutions above will help them.</p>
</div>
</div>]]></description><link>https://dannylane.github.io/2017/03/14/Getting-Started-With-NET-Core-Microservices-Using-Docker-VS-Code-on-OSX.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/14/Getting-Started-With-NET-Core-Microservices-Using-Docker-VS-Code-on-OSX.html</guid><category><![CDATA[.net]]></category><category><![CDATA[ core]]></category><category><![CDATA[ docker]]></category><category><![CDATA[ osx]]></category><category><![CDATA[ vscode]]></category><category><![CDATA[ microservice]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 14 Mar 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Extending EntityFramework Generated Model Classes With T4 Templates]]></title><description><![CDATA[<div class="paragraph">
<p>I was working on a project recently where we used a common pattern for versioning DB records. Extending the EF generated model classes made it easier for the team to apply the pattern consistently.<br>
I updated the generated code to render a generic interface if specific properties exist on the model. 2 helper methods (<code>Clone</code> &amp; <code>Update</code>) were added to the models and were regenerated whenever the model was refreshed.</p>
</div>
<div id="img-project" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/project.png" alt="project.png">
</div>
<div class="title">Figure 1. EnttityVersion.ttinclude</div>
</div>
<div class="paragraph">
<p>I added new templating content as methods exposed in a <code>.ttinclude</code> file.</p>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/t4.png" alt="t4.png">
</div>
<div class="title">Figure 2. Add reference to .ttinclude file</div>
</div>
<div class="paragraph">
<p>Using DB first EF and generating the model from the existing schema uses a t4 template, <code>model1.tt</code> by default.</p>
</div>
<div class="paragraph">
<p>The <code>.ttinclude</code> file can be added to the top of this template and every model class that is generated will include the new content you define.</p>
</div>
<div class="listingblock">
<div class="title">RenderInterfaces template method</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+void Render_Interfaces(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){
var members = ((EntityType)entity).DeclaredProperties;

var pk = entity.KeyMembers.Any(k=&gt;k.Name.EndsWith("SeqID"));
var hasEE = members.Any(m=&gt;m.Name=="EffectiveEndDate");
var hasES = members.Any(m=&gt;m.Name=="EffectiveStartDate");
var hasStatusID = members.Any(m=&gt;m.Name=="StatusID");

#&gt;
:IClonable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+if(hasEE &amp;&amp; hasES){#&gt;, IVersionable&lt;&lt;#=entity.Name #&gt;&gt;&lt;#+}#&gt;&lt;#+if(pk &amp;&amp; hasEE &amp;&amp; hasES &amp;&amp; hasStatusID){#&gt;, IStatusEntity&lt;#+}#&gt;
&lt;#+}#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Render_Interfaces</code> method checks for specific columns/properties on the model and if they exist (<code>SeqID</code>, <code>EffectiveEndDate</code> &amp; <code>EffectiveStartDate</code>) then the generated class should have the interfaces <code>IVersionable&lt;T&gt;</code> &amp; <code>IClonable&lt;T&gt;</code></p>
</div>
<div class="listingblock">
<div class="title">Adding the <code>Render_Interfaces</code> method to the Model1.tt file</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#=codeStringGenerator.EntityClassOpening(entity)#&gt; &lt;#this.Render_Interfaces(entity);#&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second method in the <code>.ttinclude</code> template is the one that adds the <code>Clone</code> and <code>Update</code> methods.</p>
</div>
<div class="listingblock">
<div class="title"><code>Clone</code> and <code>Update</code> method templates</div>
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">&lt;#+
void Render_Methods(System.Data.Entity.Core.Metadata.Edm.EntityTypeBase entity){

/// &lt;summary&gt;
/// Creates a shallow copy of the &lt;#=entity.Name #&gt;
/// Only copies primative types, should not copy primary keys
/// &lt;/summary&gt;
/// &lt;returns&gt;A new clone&lt;/returns&gt;
public &lt;#=entity.Name #&gt; Clone(){
	return new &lt;#= entity.Name #&gt;{
    &lt;#+
    for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){
		#&gt;
&lt;#=members[i].Name#&gt; = &lt;#=members[i].Name#&gt;,
	&lt;#+}
    }#&gt;
    };
}

/// &lt;summary&gt;
/// Updates the &lt;#=entity.Name #&gt; with values from the source
/// Only updates primative types, should not update primary keys
/// &lt;/summary&gt;
public void Update(&lt;#=entity.Name #&gt; source){
    &lt;#+for(var i = 0; i &lt; members.Count(); i++){
        if(!entity.KeyMembers.Any(k=&gt;k.Name == members[i].Name)){#&gt;
		this.&lt;#=members[i].Name#&gt; = source.&lt;#=members[i].Name#&gt;;
	&lt;#+}
    }#&gt;
}</code></pre>
</div>
</div>
<div id="img-t4" class="imageblock">
<div class="content">
<img src="https://dannylane.github.io/images/t4/render.png" alt="render.png">
</div>
<div class="title">Figure 3. Calling the <code>Render_Methods</code> helper method</div>
</div>
<div class="paragraph">
<p>The result of updating the interfaces and adding the <code>Clone</code> &amp; <code>Update</code> methods at the start of the class template looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c#" data-lang="c#">public partial class Employee :IClonable&lt;Employee&gt;, IVersionable&lt;Employee&gt;{
/*
    Template debug info
    ---------------------
    Has PK ending with 'SeqID' : True
    Has EE : True
    Has ES : True
    Has Status : False
    */


/// &lt;summary&gt;
/// Creates a shallow copy of the Employee
    /// Only copies primative types, should not copy primary keys
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A new clone&lt;/returns&gt;
    public Employee Clone(){
    	return new Employee{
        EID = EID,
    	PartyID = PartyID,
    	PreferredRoleID = PreferredRoleID,
    	AccessExpiryDate = AccessExpiryDate,
    	EffectiveStartDate = EffectiveStartDate,
    	EffectiveEndDate = EffectiveEndDate,
    	    };
    }

    /// &lt;summary&gt;
    /// Updates the Employee with values from the source
    /// Only updates primative types, should not update primary keys
    /// &lt;/summary&gt;
    public void Update(Employee source){
        this.EID = source.EID;
    	this.PartyID = source.PartyID;
    	this.PreferredRoleID = source.PreferredRoleID;
    	this.AccessExpiryDate = source.AccessExpiryDate;
    	this.EffectiveStartDate = source.EffectiveStartDate;
    	this.EffectiveEndDate = source.EffectiveEndDate;
    	}


    public int SeqId{
    	get{
    	return EmployeePartySeqID;
    	}
    	set{
    	EmployeePartySeqID = value;
    	}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Customizing the generated templates is pretty simple once you get the hang of the default template. I definitely prefer a code first approach, unfortunately that wasn&#8217;t an option on this project. While having to work with the <code>edmx</code> isn&#8217;t my preference, it is useful to know how to fine tune the models if needs be.</p>
</div>]]></description><link>https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</link><guid isPermaLink="true">https://dannylane.github.io/2017/03/07/Extending-Entity-Framework-Generated-Model-Classes-With-T4-Templates.html</guid><category><![CDATA[C#]]></category><category><![CDATA[ T4]]></category><category><![CDATA[ EF]]></category><dc:creator><![CDATA[Danny Lane]]></dc:creator><pubDate>Tue, 07 Mar 2017 00:00:00 GMT</pubDate></item></channel></rss>